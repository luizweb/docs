---
title: "Neo4j"
description: "Fundamentos do Neo4j"
icon: 'database'
---

# Bancos de dados de grafos

### O que são bancos de dados de grafos (graph databases)?

Grafos (graphs) são estruturas matemáticas compostas por arestas (edges) e vértices (vertices).
O Neo4j armazena e organiza dados usando nós (nodes), relacionamentos (relationships), rótulos (labels) e propriedades (properties).

![Neo4j - Graph](./images/neo4j_graph.png)

### Quando os grafos são úteis?

Grafos são particularmente úteis quando:
- O problema exige compreender os relacionamentos entre entidades.
- O problema envolve uma hierarquia.
- O problema requer explorar relacionamentos de profundidade variável ou desconhecida.
- O problema exige avaliar rotas ou caminhos em uma rede.


# Neo4j

Neo4j é um banco de dados de grafos, ou seja, armazena informações em forma de nós (nodes) e relacionamentos. 
Esse modelo é útil quando as conexões entre os dados são tão importantes quanto os próprios dados.

Nós (nodes): representam entidades ou objetos, como pessoas, empresas ou locais. 
Eles podem ter rótulos (labels) que indicam o tipo de entidade (ex.: Pessoa, Empresa). 
Um nó pode ter múltiplos rótulos, como “Pessoa” e “Funcionário”.

Relacionamentos: são as conexões (arestas) entre nós. 
Têm um tipo (ex.: trabalha em, fundado em) e direção (ex.: Michael trabalha na Neo4j). 
Relacionamentos também podem ser bidirecionais.

Propriedades: tanto nós quanto relacionamentos podem ter atributos no formato chave-valor (ex.: nome, cargo). 
Essas propriedades podem ser de diferentes tipos de dados (inteiro, string, booleano, lista) e até funcionarem como identificadores únicos.

O modelo do Neo4j, chamado de grafo de propriedades com rótulos (labelled property graph), é flexível, pois dá a mesma importância aos dados e às conexões entre eles.


### Grafos de Conhecimento e Inteligência Artificial Generativa

Os grafos tornaram-se uma parte importante no desenvolvimento de aplicações de Inteligência Artificial Generativa (Generative AI / GenAI).
Essas aplicações precisam de acesso ao significado nos dados, e os grafos de conhecimento (knowledge graphs) fornecem esse contexto.

### Casos de uso em Neo4j e GenAI

Há muitos casos de uso combinando Neo4j e GenAI, incluindo:
- Busca vetorial (vector search)
- Grafos de conhecimento (knowledge graph)
- Ciência de dados (data science)


# Neo4j AuraDB

AuraDB é um serviço de nuvem totalmente gerenciado (fully managed cloud service) que fornece um banco de dados Neo4j como serviço (Neo4j database as a service).

Trata-se de um serviço de banco de dados em nuvem totalmente gerenciado, escalável e seguro (fully managed, scalable, and secure cloud database service), que permite que você se concentre no desenvolvimento de aplicações sem se preocupar com os aspectos operacionais da administração de um banco de dados.

https://neo4j.com/product/auradb/

# Links

- [Neo4j](https://neo4j.com/)
- [Manual do Cypher](https://neo4j.com/docs/cypher-manual/current/introduction/)
- [Cypher Cheat Sheet](https://neo4j.com/docs/cypher-cheat-sheet/5/all/)
- [Data Importer](https://data-importer.neo4j.io/)
- [Workspace Preview](https://workspace-preview.neo4j.io/)
- [Sandbox](https://sandbox.neo4j.com/)
- [Arrows](https://arrows.app/)
- [AuraDB](https://console.neo4j.io/)
- [Neodash - Dashboard](https://neodash.graphapp.io/)
- [Graph Academy](https://graphacademy.neo4j.com/)
- [GraphRAG](https://graphrag.com/)


# Cypher

A linguagem de consulta Cypher (Cypher query language) é utilizada para interagir com um banco de dados de grafos Neo4j (Neo4j graph database).

![Neo4j - Cypher](./images/neo4j_cypher.png)

Os nós são representados entre parênteses, e cada nó pode ter um rótulo (label) definido por dois pontos seguidos do nome. Labels agrupam nós com o mesmo conjunto de propriedades (properties). No exemplo, nós do tipo person representam pessoas e nós do tipo movie representam filmes.

Relações (relationships) conectam os nós e definem a estrutura do grafo. Em Cypher, usam-se dois traços (- -) ou dois traços com seta (- ->) para representar a relação. Cada relação deve ter uma direção e um tipo, especificado entre colchetes com dois pontos e o tipo da relação. Ex.: [:ACTED_IN], [:DIRECTED].

Tanto nós quanto relações podem ter propriedades (properties), definidas entre chaves {} como pares chave-valor. Exemplo: um nó person com propriedade name: "Tom Hanks" e um nó movie com title: "Cloud Atlas".

Para consultar, define-se um padrão (pattern) no grafo. Exemplo: buscar o nó person com name: "Tom Hanks" conectado por uma relação ACTED_IN a um nó movie com title: "Cloud Atlas".

Usa-se MATCH para encontrar o padrão.

Usa-se RETURN para retornar os nós ou propriedades desejadas.

O processador da query encontra o nó inicial que satisfaz o critério, percorre a relação definida e retorna o resultado filtrado.




### Consultas

Exemplo:
```cypher
MATCH
(p:Person {name: 'Tom Hanks'})-[r:ACTED_IN]->(m:Movie {title: 'Cloud Atlas'})
RETURN p, r, m;
```
O resultado pode ser visualizado no neo4j browser como grafo ou em tabela.

Para retornar propriedades específicas, utiliza-se a variável do nó. Exemplo:
```cypher
RETURN p.name
```

Também é possível aplicar filtros com WHERE, permitindo expressões lógicas. Exemplo:;
```cypher
MATCH (p:Person) 
WHERE p.name = "Tom Hanks" OR p.name = "Rita Wilson"
RETURN p
```

### Filtrando consultas

O comando WHERE é usado para filtrar quais nós (nodes) ou relacionamentos (relationships) são retornados em uma consulta. Há diversas formas de aplicar filtros em Cypher:

**Igualdade e expressões lógicas**

Permite testar propriedades (properties) de nós com condições de igualdade e operadores lógicos (AND, OR, NOT).

```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE m.released = 2008 OR m.released = 2009
RETURN p, m
```

**Filtragem por labels**

Pode-se definir o label diretamente no MATCH ou dentro do WHERE.

```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE m.title = 'The Matrix'
RETURN p.name

MATCH (p)-[:ACTED_IN]->(m)
WHERE p:Person AND m:Movie AND m.title='The Matrix'
RETURN p.name
```

**Faixas numéricas (ranges)**

Consulta dentro de um intervalo de valores.


```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE 2000 <= m.released <= 2003
RETURN p.name, m.title, m.released
```

**Existência de propriedade**

Usa IS NOT NULL para garantir que a propriedade existe.

```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name='Jack Nicholson' AND m.tagline IS NOT NULL
RETURN m.title, m.tagline
```

**Strings parciais**

Utiliza STARTS WITH, ENDS WITH, CONTAINS.

```cypher
MATCH (p:Person)-[:ACTED_IN]->()
WHERE p.name STARTS WITH 'Michael'
RETURN p.name
```

Para evitar problemas de maiúsculas/minúsculas, pode-se usar toLower() ou toUpper().

```cypher
WHERE toLower(p.name) STARTS WITH 'michael'
```


**Padrões no grafo**

Filtrar pela existência (ou ausência) de um relacionamento.

```cypher
MATCH (p:Person)-[:WROTE]->(m:Movie)
WHERE NOT exists((p)-[:DIRECTED]->(m))
RETURN p.name, m.title
```

**Listas**

Permite comparar valores diretamente com uma lista (IN).

```cypher
MATCH (p:Person)
WHERE p.born IN [1965, 1970, 1975]
RETURN p.name, p.born
```

Também pode verificar se um valor está em uma lista armazenada como propriedade:

```cypher
MATCH (p:Person)-[r:ACTED_IN]->(m:Movie)
WHERE 'Neo' IN r.roles AND m.title='The Matrix'
RETURN p.name, r.roles
```

**Descobrindo propriedades**

`keys(node)` retorna as propriedades de um nó.

```cypher
MATCH (p:Person)
RETURN p.name, keys(p)
```


### Criando nós

**Criando um nó com `MERGE`**

O comando MERGE é usado para criar um padrão (pattern) no banco de dados.

Exemplo: criar um nó Person com nome Michael Caine:

```cypher
MERGE (p:Person {name: 'Michael Caine'})
```

Ao usar MERGE, é obrigatório especificar pelo menos uma propriedade que funcione como chave primária (primary key).

Para verificar se o nó foi criado:

```cypher
MATCH (p:Person {name: 'Michael Caine'})
RETURN p
```

**Executando múltiplos MERGE**

É possível encadear vários MERGE no mesmo bloco de código.

Exemplo: criar um nó Person e um nó Movie:

```cypher
MERGE (p:Person {name: 'Katie Holmes'})
MERGE (m:Movie {title: 'The Dark Knight'})
RETURN p, m
```

Aqui, `p` e `m` são variáveis que permitem retornar os nós criados.

**Usando CREATE em vez de MERGE**

O comando CREATE também cria nós, mas sem verificar duplicação.

- Vantagem: mais rápido, útil em importações de dados limpos.

- Desvantagem: pode gerar nós duplicados.


### Criando relacionamentos entre nós

**Criando relacionamentos com MERGE**

Assim como para criar nós, usamos MERGE para criar relacionamentos.
Um relacionamento deve ter:

- Tipo (Type)  ex.: :ACTED_IN

- Direção (Direction)  `-->` ou `<--`

Exemplo: criar um relacionamento entre Person e Movie já existentes:

```cypher
MATCH (p:Person {name: 'Michael Caine'})
MATCH (m:Movie {title: 'The Dark Knight'})
MERGE (p)-[:ACTED_IN]->(m)
```

**Confirmando o relacionamento**

Podemos verificar se a relação existe:

```cypher
MATCH (p:Person {name: 'Michael Caine'})-[:ACTED_IN]-(m:Movie {title: 'The Dark Knight'})
RETURN p, m
```

> No MATCH, a direção não é obrigatória. Se for invertida erroneamente, nenhum resultado será retornado.

**Criando nós e relacionamentos em múltiplas cláusulas**

É possível encadear várias cláusulas MERGE para criar nós e depois o relacionamento:

```cypher
MERGE (p:Person {name: 'Chadwick Boseman'})
MERGE (m:Movie {title: 'Black Panther'})
MERGE (p)-[:ACTED_IN]-(m)
```

Se a direção não for especificada, o padrão assumido é da esquerda para a direita.

**Criando nós e relacionamento em uma única cláusula**

O MERGE também pode criar nós e relacionamento de uma só vez:

```cypher
MERGE (p:Person {name: 'Emily Blunt'})-[:ACTED_IN]->(m:Movie {title: 'A Quiet Place'})
RETURN p, m
```

Esse comando pode ser executado várias vezes sem criar duplicações — MERGE garante que nós e relacionamentos só sejam criados se ainda não existirem.

### Atualizando propriedades

Em Cypher, é possível adicionar, modificar ou remover propriedades (properties) de nós (nodes) e relacionamentos (relationships).

**Definindo propriedades inline no MERGE**

Podemos definir propriedades diretamente no MERGE, usando o estilo JSON {}.

```cypher
MATCH (p:Person {name: 'Michael Caine'})
MERGE (m:Movie {title: 'Batman Begins'})
MERGE (p)-[:ACTED_IN {roles: ['Alfred Penny']}]->(m)
RETURN p, m
```

Resultado:

- `p` já existe.

- `m` é criado.

- A relação ACTED_IN recebe a propriedade roles.

**Usando `SET`**

Com uma variável que referencia um nó ou relacionamento, podemos usar SET para definir propriedades:

```cypher
MATCH (p:Person)-[r:ACTED_IN]->(m:Movie)
WHERE p.name = 'Michael Caine' AND m.title = 'The Dark Knight'
SET r.roles = ['Alfred Penny']
RETURN p, r, m
```

Para múltiplas propriedades:

```cypher
SET r.roles = ['Alfred Penny'], m.released = 2008
```

**Atualizando valores**

O SET também pode ser usado para modificar valores existentes:

```cypher
SET r.roles = ['Mr. Alfred Penny']
```

**Removendo propriedades**

Duas formas de remover propriedades:

`REMOVE`:

```cypher
REMOVE r.roles
```

`SET` `null`:

```cypher
SET p.born = null
```

> Nunca remover a propriedade usada como chave primária (primary key).

### Processamento do MERGE

O comando MERGE tenta primeiro encontrar um padrão (pattern) no grafo:

- Se o padrão for encontrado, nada é criado.

- Se o padrão não for encontrado, o nó ou relacionamento é criado.

**Personalizando o comportamento do MERGE**

Podemos definir ações diferentes dependendo se o nó foi criado ou encontrado:

- `ON CREATE SET` → define propriedades apenas quando o nó é criado.

- `ON MATCH SET` → define propriedades apenas quando o nó já existia e foi encontrado.

- `SET` → define propriedades sempre, independentemente da criação ou não.

Exemplo:

```cypher
MERGE (p:Person {name: 'McKenna Grace'})
ON CREATE SET p.createdAt = datetime()
ON MATCH SET p.updatedAt = datetime()
SET p.born = 2006
RETURN p
```

- Se o nó não existe → cria e adiciona createdAt.

- Se já existe → atualiza updatedAt.

- Em ambos os casos → define born = 2006.

Para múltiplas propriedades em um mesmo ON CREATE SET ou ON MATCH SET, separa-se por vírgulas:

```cypher
ON CREATE SET m.released = 2020, m.tagline = 'A great ride!'
```

**MERGE com relacionamentos**

O MERGE pode ser usado tanto para nós quanto para relacionamentos.

Exemplo em múltiplas cláusulas:
```cypher
MERGE (p:Person {name: 'Michael Caine'})
MERGE (m:Movie {title: 'The Cider House Rules'})
MERGE (p)-[:ACTED_IN]->(m)
```


Exemplo em cláusula única:
```cypher
MERGE (p:Person {name: 'Michael Caine'})-[:ACTED_IN]->(m:Movie {title: 'The Cider House Rules'})
RETURN p, m
```

*O que acontece no processador da query*

- Procura um nó Person com name = 'Michael Caine'.

    - Se não existir → cria.

- Expande os relacionamentos ACTED_IN a partir desse nó.

- Procura um nó Movie com title = 'The Cider House Rules'.

    - Se não existir → cria.

- Verifica se já existe o relacionamento ACTED_IN entre os dois nós.

    - Se não existir → cria a relação.


### Deletando dados

No Neo4j, é possível deletar:

- nós (nodes)

- relacionamentos (relationships)

- propriedades (properties)

- rótulos (labels)

Para deletar qualquer dado, é necessário primeiro recuperá-lo com um MATCH e depois aplicar o comando DELETE (ou equivalente).

**Deletando um nó**

Criando e deletando um nó Person:

```cypher
MERGE (p:Person {name: 'Jane Doe'})

MATCH (p:Person {name: 'Jane Doe'})
DELETE p
```

> Se o nó tiver relacionamentos, ocorrerá erro porque o Neo4j não permite deixar relacionamentos órfãos.

**Deletando um relacionamento**

Criando nó + relacionamento:

```cypher
MATCH (m:Movie {title: 'The Matrix'})
MERGE (p:Person {name: 'Jane Doe'})
MERGE (p)-[:ACTED_IN]->(m)
RETURN p, m
```

Deletando apenas o relacionamento, mas mantendo o nó:

```cypher
MATCH (p:Person {name: 'Jane Doe'})-[r:ACTED_IN]->(m:Movie {title: 'The Matrix'})
DELETE r
RETURN p, m
```

**Deletando um nó e seus relacionamentos**

Para remover um nó junto com seus relacionamentos, usa-se DETACH DELETE:

```cypher
MATCH (p:Person {name: 'Jane Doe'})
DETACH DELETE p
```


Deletando tudo (*consome muita memória em bases grandes*):

```cypher
MATCH (n)
DETACH DELETE n
```

**Deletando labels**

Criando nó com label Person:
```cypher
MERGE (p:Person {name: 'Jane Doe'})
RETURN p
```

Adicionando novo label:
```cypher
MATCH (p:Person {name: 'Jane Doe'})
SET p:Developer
RETURN p
```

Removendo label:
```cypher
MATCH (p:Person {name: 'Jane Doe'})
REMOVE p:Developer
RETURN p
```

Um nó pode ter múltiplos labels (Person, Developer). Eles podem ser combinados no MATCH.

**Descobrindo labels existentes no grafo**
```cypher
CALL db.labels()
```

---

# Cypher - Consultas intermediárias

Visualizar o modelo de dados:
```cypher
CALL db.schema.visualization()
```

Tipos de propriedade dos nós no grafo:
```cypher
CALL db.schema.nodeTypeProperties()
```

Visualizar os tipos de propriedade para relacionamentos:;
```cypher
CALL db.schema.relTypeProperties()
```

Visualizar os índices de restrição de exclusividade (CONSTRAINTS):
```cypher
SHOW CONSTRAINTS
```

### Filtrando Consultas
```cypher
//Testing Equality
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = 'Tom Hanks'
AND m.year = 2013
RETURN m.title

//Testing Inequality
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name <> 'Tom Hanks'
AND m.title = 'Captain Phillips'
RETURN p.name

//Testing less than or greater than
MATCH (m:Movie) WHERE m.title = 'Toy Story'
RETURN
    m.year < 1995 AS lessThan, //  Less than (false)
    m.year <= 1995 AS lessThanOrEqual, // Less than or equal(true)
    m.year > 1995 AS moreThan, // More than (false)
    m.year >= 1995 AS moreThanOrEqual // More than or equal (true)

//Testing Ranges
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = 'Tom Hanks'
AND  2005 <= m.year <= 2010
RETURN m.title, m.released

MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = 'Tom Hanks'
OR m.title = 'Captain Phillips'
RETURN p.name, m.title

//Testing null property values
MATCH (p:Person)
WHERE p.died IS NOT NULL
AND p.born.year >= 1985
RETURN p.name, p.born, p.died

MATCH (p:Person)
WHERE p.died IS NULL
AND p.born.year <= 1922
RETURN p.name, p.born, p.died

//Testing labels or patterns?
MATCH (p:Person)
WHERE  p.born.year > 1960
AND p:Actor
AND p:Director
RETURN p.name, p.born, labels(p)

MATCH (p:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(p)
WHERE  p.born.year > 1960
RETURN p.name, p.born, labels(p), m.title

//Discovering relationship types
MATCH (p:Person)-[r]->(m:Movie)
WHERE  p.name = 'Tom Hanks'
RETURN m.title AS movie, type(r) AS relationshipType

//Testing list inclusion
MATCH (m:Movie)
WHERE "Israel" IN m.countries
RETURN m.title, m.languages, m.countries
```

### Testando Strings
```cypher
// --- Testing strings ---
MATCH (m:Movie)
WHERE  m.title STARTS WITH 'Toy Story'
RETURN m.title, m.released

MATCH (m:Movie)
WHERE  m.title ENDS WITH ' I'
RETURN m.title, m.released

MATCH (m:Movie)
WHERE  m.title CONTAINS 'River'
RETURN m.title, m.released

//Case-sensitive strings
MATCH (p:Person)
WHERE toLower(p.name) ENDS WITH 'demille'
RETURN p.name

MATCH (p:Person)
WHERE toUpper(p.name) ENDS WITH 'DEMILLE'
RETURN p.name

MATCH (p:Person)
WHERE toUpper(p.name) CONTAINS ' DE '
RETURN p.name

//About indexes for queries
//If you transform a string property during a query, such as toUpper() or toLower(), the query engine turns off the use of the index.

//EXPLAIN
EXPLAIN MATCH (m:Movie)
WHERE  m.title STARTS WITH 'Toy Story'
RETURN m.title, m.released

EXPLAIN MATCH (p:Person)
WHERE toLower(p.name) ENDS WITH 'demille'
RETURN p.name
```

You can view the data model by executing this query:

```cypher
CALL db.schema.visualization()
```

Property types for nodes 
```cypher
CALL db.schema.nodeTypeProperties()
```

Property types for relationships 
```cypher
CALL db.schema.relTypeProperties()
```

You can view the uniqueness constraint indexes in the graph by executing this query:
```cypher
SHOW CONSTRAINTS
```


### Testing Equality
```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = 'Tom Hanks'
AND m.year = 2013
RETURN m.title
```

### Testing Inequality
```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name <> 'Tom Hanks'
AND m.title = 'Captain Phillips'
RETURN p.name
```

### Testing less than or greater than
```cypher
MATCH (m:Movie) WHERE m.title = 'Toy Story'
RETURN
    m.year < 1995 AS lessThan, //  Less than (false)
    m.year <= 1995 AS lessThanOrEqual, // Less than or equal(true)
    m.year > 1995 AS moreThan, // More than (false)
    m.year >= 1995 AS moreThanOrEqual // More than or equal (true)
```

### Testing Ranges
```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = 'Tom Hanks'
AND  2005 <= m.year <= 2010
RETURN m.title, m.released
```

```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = 'Tom Hanks'
OR m.title = 'Captain Phillips'
RETURN p.name, m.title
```

### Testing `null` property values
```cypher
MATCH (p:Person)
WHERE p.died IS NOT NULL
AND p.born.year >= 1985
RETURN p.name, p.born, p.died
```

```cypher
MATCH (p:Person)
WHERE p.died IS NULL
AND p.born.year <= 1922
RETURN p.name, p.born, p.died
```

### Testing labels or patterns?
Depending on your data model, it may be useful to test that a node has a label. This is particularly useful when a node may have multiple labels.

```cypher
MATCH (p:Person)
WHERE  p.born.year > 1960
AND p:Actor
AND p:Director
RETURN p.name, p.born, labels(p)
```

```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(p)
WHERE  p.born.year > 1960
RETURN p.name, p.born, labels(p), m.title
```
### Discovering relationship types
```cypher
MATCH (p:Person)-[r]->(m:Movie)
WHERE  p.name = 'Tom Hanks'
RETURN m.title AS movie, type(r) AS relationshipType
```

### Testing list inclusion
```cypher
MATCH (m:Movie)
WHERE "Israel" IN m.countries
RETURN m.title, m.languages, m.countries
```

### Testing strings
```cypher
MATCH (m:Movie)
WHERE  m.title STARTS WITH 'Toy Story'
RETURN m.title, m.released
```

```cypher
MATCH (m:Movie)
WHERE  m.title ENDS WITH ' I'
RETURN m.title, m.released
```

```cypher
MATCH (m:Movie)
WHERE  m.title CONTAINS 'River'
RETURN m.title, m.released
```

### Case-sensitive strings
```cypher
MATCH (p:Person)
WHERE toLower(p.name) ENDS WITH 'demille'
RETURN p.name
```

```cypher
MATCH (p:Person)
WHERE toUpper(p.name) ENDS WITH 'DEMILLE'
RETURN p.name
```

```cypher
MATCH (p:Person)
WHERE toUpper(p.name) CONTAINS ' DE '
RETURN p.name
```

### About indexes for queries
```cypher
EXPLAIN MATCH (m:Movie)
WHERE  m.title STARTS WITH 'Toy Story'
RETURN m.title, m.released
```

```cypher
EXPLAIN MATCH (p:Person)
WHERE toLower(p.name) ENDS WITH 'demille'
RETURN p.name
```


----
### Patterns in the graph
```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE  p.name = 'Tom Hanks'
AND exists {(p)-[:DIRECTED]->(m)}
RETURN p.name, labels(p), m.title
```

### Profiling queries
You can use the PROFILE keyword to show the total number of rows retrieved from the graph in the query.
```cypher
PROFILE MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE  p.name = 'Tom Hanks'
AND exists {(p)-[:DIRECTED]->(m)}
RETURN m.title
```

```cypher
PROFILE MATCH (p:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(p)
WHERE  p.name = 'Tom Hanks'
RETURN  m.title
```
### Finding non-patterns - NOT exists
```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE  p.name = 'Tom Hanks'
AND NOT exists {(p)-[:DIRECTED]->(m)}
RETURN  m.title
```

### Multiple MATCH Clauses
```cypher
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)
WHERE m.year > 2000
MATCH (m)<-[:DIRECTED]-(d:Person)
RETURN a.name, m.title, d.name
```

### Using multiple patterns in the MATCH clause
```cypher
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)
WHERE m.year > 2000
MATCH (m)<-[:DIRECTED]-(d:Person)
RETURN a.name, m.title, d.name
```

### Using a single pattern
```cypher
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(d:Person)
WHERE m.year > 2000
RETURN a.name, m.title, d.name
```

### Optionally matching rows
```cypher
MATCH (m:Movie) WHERE m.title = "Kiss Me Deadly"
MATCH (m)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(rec:Movie)
MATCH (m)<-[:ACTED_IN]-(a:Actor)-[:ACTED_IN]->(rec)
RETURN rec.title, a.name
```

### OPTIONAL MATCH
OPTIONAL MATCH could be considered the Cypher equivalent of the outer join in SQL.
```cypher
MATCH (m:Movie) WHERE m.title = "Kiss Me Deadly"
MATCH (m)-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(rec:Movie)
OPTIONAL MATCH (m)<-[:ACTED_IN]-(a:Actor)-[:ACTED_IN]->(rec)
RETURN rec.title, a.name
```

## Controlling Results Returned

### Ordering Returned Results
```cypher
MATCH (p:Person)
WHERE p.born.year = 1980
RETURN p.name AS name,
p.born AS birthDate
ORDER BY p.born
```
```cypher
MATCH (p:Person)
WHERE p.born.year = 1980
RETURN p.name AS name, p.born AS birthDate
ORDER BY p.born DESC
```

### Eliminating null values returned
```cypher
MATCH (p:Person)
RETURN p.name AS name, p.born AS birthDate
ORDER BY p.born DESC
```
```cypher
MATCH (p:Person)
WHERE p.born IS NOT NULL
RETURN p.name AS name, p.born AS birthDate
ORDER BY p.born DESC
```
### Ordering multiple results
```cypher
MATCH (p:Person)-[:DIRECTED | ACTED_IN]->(m:Movie)
WHERE p.name = 'Tom Hanks'
OR p.name = 'Keanu Reeves'
RETURN  m.year, m.title
ORDER BY m.year DESC , m.title
```

### Limiting results
```cypher
MATCH (m:Movie)
WHERE m.released IS NOT NULL
RETURN m.title AS title,
m.released AS releaseDate
ORDER BY m.released DESC LIMIT 100
```
```cypher
MATCH (p:Person) WHERE
p.born IS NOT NULL
RETURN p.name as name,
p.born AS birthDate
ORDER BY p.born DESC LIMIT 1
```

### Skipping some results
In this query, we return 10 rows representing page 5, where each page contains 10 rows.
```cypher
MATCH (p:Person)
WHERE p.born.year = 1980
RETURN  p.name as name,
p.born AS birthDate
ORDER BY p.born SKIP 40 LIMIT 10
```

### Eliminating duplicate records
```cypher
MATCH (p:Person)-[:DIRECTED | ACTED_IN]->(m:Movie)
WHERE p.name = 'Tom Hanks'
RETURN DISTINCT m.title, m.released
ORDER BY m.title
```
### Uses of DISTINCT
```cypher
MATCH (m:Movie)
RETURN DISTINCT m.year
ORDER BY m.year
```

```cypher
MATCH (p:Person)-[:DIRECTED | ACTED_IN]->(m:Movie)
WHERE p.name = 'Tom Hanks'
RETURN  DISTINCT m
```

## Map projections
```cypher
MATCH (p:Person)
WHERE p.name CONTAINS "Thomas"
RETURN p AS person
ORDER BY p.name ASC
```
Another way that you can return data is without the internal node information, that is, only property values.
```cypher
MATCH (p:Person)
WHERE p.name CONTAINS "Thomas"
RETURN p { .* } AS person
ORDER BY p.name ASC
```

```cypher
MATCH (p:Person)
WHERE p.name CONTAINS "Thomas"
RETURN p { .name, .born } AS person
ORDER BY p.name
```

```cypher
MATCH (m:Movie)<-[:DIRECTED]-(d:Director)
WHERE d.name = 'Woody Allen'
RETURN m {.*, favorite: true} AS movie
```

## Changing data returned
```cypher
MATCH (m:Movie)<-[:ACTED_IN]-(p:Person)
WHERE m.title CONTAINS 'Toy Story' AND
p.died IS NULL
RETURN m.title AS movie,
p.name AS actor,
p.born AS dob,
date().year - p.born.year AS ageThisYear
```

```cypher
MATCH (m:Movie)<-[:ACTED_IN]-(p:Person)
WHERE m.title CONTAINS 'Toy Story' AND
p.died IS NULL
RETURN 'Movie: ' + m.title AS movie,
p.name AS actor,
p.born AS dob,
date().year - p.born.year AS ageThisYear
```
### Conditionally changing data returned
```cypher
MATCH (m:Movie)<-[:ACTED_IN]-(p:Person)
WHERE p.name = 'Henry Fonda'
RETURN m.title AS movie,
CASE
WHEN m.year < 1940 THEN 'oldies'
WHEN 1940 <= m.year < 1950 THEN 'forties'
WHEN 1950 <= m.year < 1960 THEN 'fifties'
WHEN 1960 <= m.year < 1970 THEN 'sixties'
WHEN 1970 <= m.year < 1980 THEN 'seventies'
WHEN 1980 <= m.year < 1990 THEN 'eighties'
WHEN 1990 <= m.year < 2000 THEN 'nineties'
ELSE  'two-thousands'
END
AS timeFrame
```

## Aggregating Data

### Using count() to aggregate data
```cypher
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)
WHERE a.name = 'Tom Hanks'
RETURN a.name AS actorName,
count(*) AS numMovies
```

```cypher
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(d:Person)
RETURN a.name AS actorName,
d.name AS directorName,
count(*) AS numMovies
ORDER BY numMovies DESC
```
### Returning a list
```cypher
MATCH (p:Person)
RETURN p.name, [p.born, p.died] AS lifeTime
LIMIT 10
```
### Using collect() to create a list
```cypher
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)
RETURN a.name AS actor,
count(*) AS total,
collect(m.title) AS movies
ORDER BY total DESC LIMIT 10
```
### Eliminating duplication in lists
```cypher
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)
WHERE m.year = 1920
RETURN  collect( DISTINCT m.title) AS movies,
collect( a.name) AS actors
```

### Collecting nodes
```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name ='Tom Cruise'
RETURN collect(m) AS tomCruiseMovies
```

### Accessing elements of a list
```cypher
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)
RETURN m.title AS movie,
collect(a.name)[0] AS castMember,
size(collect(a.name)) as castSize
```

```cypher
MATCH (a:Person)-[:ACTED_IN]->(m:Movie)
RETURN m.title AS movie,
collect(a.name)[2..] AS castMember,
size(collect(a.name)) as castSize
```
Other aggregating functions
There are more aggregating functions that may be useful for your application such as:

`min()`, `max()`, `avg()`, `stddev()`, `sum()`

### count() versus size()
```cypher
MATCH (actor:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(director:Person)
RETURN actor.name, director.name,
size(collect(m)) AS collaborations,
collect(m.title) AS movies
```

### List comprehension
```cypher
MATCH (m:Movie)
RETURN m.title as movie,
[x IN m.countries WHERE x CONTAINS 'USA' OR x CONTAINS 'Germany']
AS country LIMIT 500
```

### Pattern comprehension
```cypher
MATCH (m:Movie)
WHERE m.year = 2015
RETURN m.title,
[(dir:Person)-[:DIRECTED]->(m) | dir.name] AS directors,
[(actor:Person)-[:ACTED_IN]->(m) | actor.name] AS actors
```

### Working with maps
```cypher
RETURN {Jan: 31, Feb: 28, Mar: 31, Apr: 30 ,
May: 31, Jun: 30 , Jul: 31, Aug: 31, Sep: 30,
Oct: 31, Nov: 30, Dec: 31}['Feb'] AS daysInFeb
```

```cypher
RETURN {Jan: 31, Feb: 28, Mar: 31, Apr: 30 ,
May: 31, Jun: 30 , Jul: 31, Aug: 31, Sep: 30,
Oct: 31, Nov: 30, Dec: 31}.Feb AS daysInFeb
```

```cypher
RETURN keys({Jan: 31, Feb: 28, Mar: 31, Apr: 30 ,
May: 31, Jun: 30 ,Jul: 31, Aug: 31, Sep: 30,
Oct: 31, Nov: 30, Dec: 31}) AS months
```
## Working with Dates and Times

### Date and Time data in Cypher
```cypher
RETURN date(), datetime(), time()
```

```cypher
MERGE (x:Test {id: 1})
SET x.date = date(),
    x.datetime = datetime(),
    x.time = time()
RETURN x
```
### Extracting components of a date or datetime
```cypher
MATCH (x:Test {id: 1})
RETURN x.date.day, x.date.year,
x.datetime.year, x.datetime.hour,
x.datetime.minute
```

### Setting date values
```cypher
MATCH (x:Test {id: 1})
SET x.date1 = date('2022-01-01'),
    x.date2 = date('2022-01-15')
RETURN x
```
### Setting datetime values
```cypher
MATCH (x:Test {id: 1})
SET x.datetime1 = datetime('2022-01-04T10:05:20'),
    x.datetime2 = datetime('2022-04-09T18:33:05')
RETURN x
```
### Working with durations
```cypher
MATCH (x:Test {id: 1})
RETURN duration.between(x.date1,x.date2)
```

```cypher
MATCH (x:Test {id: 1})
RETURN duration.inDays(x.datetime1,x.datetime2).days
```

```cypher
MATCH (x:Test {id: 1})
RETURN x.date1 + duration({months: 6})
```
### Using APOC to format dates and times
```cypher
MATCH (x:Test {id: 1})
RETURN x.datetime as Datetime,
apoc.temporal.format( x.datetime, 'HH:mm:ss.SSSS')
AS formattedDateTime
```

```cypher
MATCH (x:Test {id: 1})
RETURN apoc.date.toISO8601(x.datetime.epochMillis, "ms")
AS iso8601
```
## Graph Traversal

### Anchor of a query
```cypher
PROFILE MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = 'Eminem'
RETURN p.name, m.title
```
### Multiple anchors
```cypher
PROFILE
MATCH (p1:Person)-[:ACTED_IN]->(m1)
MATCH (m2)<-[:ACTED_IN]-(p2:Person)
WHERE p1.name = 'Tom Hanks'
AND p2.name = 'Meg Ryan'
AND m1 = m2
RETURN m1.title
```
### Expand to follow paths
```cypher
PROFILE MATCH (m:Movie)<--(p:Person)
WHERE p.name = 'Clint Eastwood'
RETURN  m.title
```
### Basic query traversal
```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = 'Eminem'
RETURN  m.title AS movies
```
### Query traversal using multiple patterns
```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie),
(coActors:Person)-[:ACTED_IN]->(m)
WHERE p.name = 'Eminem'
RETURN m.title AS movie ,collect(coActors.name) AS coActors
```

### Query traversal using multiple MATCH clauses
```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = 'Eminem'
MATCH (allActors:Person)-[:ACTED_IN]->(m)
RETURN m.title AS movie, collect(allActors.name) AS allActors
```
### Avoiding labels for better performance
```cypher
PROFILE MATCH (p:Person)-[:ACTED_IN]->(m)
WHERE p.name = 'Tom Hanks'
RETURN m.title AS movie
```
### Returning paths
```cypher
MATCH p = ((person:Person)-[]->(movie))
WHERE person.name = 'Walt Disney'
RETURN p
```

## Varying Length Traversal

### Shortest path
```cypher
MATCH p = shortestPath((p1:Person)-[*]-(p2:Person))
WHERE p1.name = "Eminem"
AND p2.name = "Charlton Heston"
RETURN  p
```

```cypher
MATCH p = shortestPath((p1:Person)-[:ACTED_IN*]-(p2:Person))
WHERE p1.name = "Eminem"
AND p2.name = "Charlton Heston"
RETURN  p
```
Path Length Bounds

For shortestPath() and allShortestPaths() you can provide an upper bound on the length of the path(s), but not a lower bound.

### Varying length traversal
```cypher
MATCH (p:Person {name: 'Eminem'})-[:ACTED_IN*2]-(others:Person)
RETURN  others.name
```
### Four hops away
```cypher
MATCH (p:Person {name: 'Eminem'})-[:ACTED_IN*4]-(others:Person)
RETURN  others.name
```
### Up to four hops away
```cypher
MATCH (p:Person {name: 'Eminem'})-[:ACTED_IN*1..4]-(others:Person)
RETURN  others.name
```

## Scoping Variables

### Scoping variables for a query
```cypher
WITH 'Tom Hanks' AS actorName
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = actorName
RETURN m.title AS movies
```
### Using WITH to redefine scope
```cypher
WITH  'toy story' AS mt, 'Tom Hanks' AS actorName
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WITH m, toLower(m.title) AS movieTitle
WHERE p.name = actorName
AND movieTitle CONTAINS mt
RETURN m.title AS movies, movieTitle
```

### Limiting results
```cypher
WITH  'Tom Hanks' AS theActor
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = theActor
RETURN m.title AS movies LIMIT 2
```

```cypher
WITH  'Tom Hanks' AS theActor
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = theActor
WITH m  LIMIT 2
// possibly do more with the two m nodes
RETURN m.title AS movies
```

### Ordering results
```cypher
WITH  'Tom Hanks' AS theActor
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = theActor
WITH m ORDER BY m.year LIMIT 5
// possibly do more with the five m nodes in a particular order
RETURN m.title AS movies, m.year AS yearReleased
```

### Using map projections in a WITH clause
```cypher
MATCH (n:Movie)
WHERE n.imdbRating IS NOT NULL
AND n.poster IS NOT NULL
WITH n {
  .title,
  .year,
  .languages,
  .plot,
  .poster,
  .imdbRating,
  directors: [ (n)<-[:DIRECTED]-(d) | d { tmdbId:d.imdbId, .name } ]
}
ORDER BY n.imdbRating DESC LIMIT 4
RETURN collect(n)
```
## Pipelining Queries

### What does pipelining mean?
```cypher
WITH  'Tom Hanks' AS theActor
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = theActor
WITH m  LIMIT 5
// possibly do more with the five m nodes
RETURN m.title AS movies
```

```cypher
WITH  'Tom Hanks' AS theActor
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = theActor
WITH m  LIMIT 5
MATCH (d:Person)-[:DIRECTED]->(m)
RETURN d.name AS director,
m.title AS movies
```
### Using WITH for aggregation
```cypher
MATCH (:Movie {title: 'Toy Story'})-[:IN_GENRE]->(g:Genre)<-[:IN_GENRE]-(m)
WHERE m.imdbRating IS NOT NULL
WITH g.name AS genre,
count(m) AS moviesInCommon,
sum(m.imdbRating) AS total
RETURN genre, moviesInCommon,
total/moviesInCommon AS score
ORDER By score DESC
```

```cypher
MATCH (u:User {name: "Misty Williams"})-[r:RATED]->(:Movie)
WITH u, avg(r.rating) AS average
MATCH (u)-[r:RATED]->(m:Movie)
WHERE r.rating > average
RETURN average , m.title AS movie,
r.rating as rating
ORDER BY rating DESC
```
### Using WITH for collecting
```cypher
MATCH (m:Movie)--(a:Actor)
WHERE m.title CONTAINS 'New York'
WITH m, collect (a.name) AS actors,
count(*) AS numActors
RETURN m.title AS movieTitle, actors
ORDER BY numActors DESC
```

```cypher
MATCH (m:Movie)<-[:ACTED_IN]-(a:Actor)
WHERE m.title CONTAINS 'New York'
WITH m, collect (a.name) AS actors,
count(*) AS numActors
ORDER BY numActors DESC
RETURN collect(m { .title, actors, numActors }) AS movies
```

### Using LIMIT early
```cypher
PROFILE MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.born.year = 1980
WITH p,
collect(m.title) AS movies LIMIT 3
RETURN p.name AS actor, movies
```

```cypher
PROFILE MATCH (p:Actor)
WHERE p.born.year = 1980
WITH p  LIMIT 3
MATCH (p)-[:ACTED_IN]->(m:Movie)
WITH p, collect(m.title) AS movies
RETURN p.name AS actor,  movies
```

### Use DISTINCT when necessary
```cypher
MATCH (p:Actor)
WHERE p.born.year = 1980
WITH p  LIMIT 3
MATCH (p)-[:ACTED_IN]->(m:Movie)-[:IN_GENRE]->(g:Genre)
WITH p, collect(g.name) AS genres
RETURN p.name AS actor, genres
```

```cypher
MATCH (p:Actor)
WHERE p.born.year = 1980
WITH p  LIMIT 3
MATCH (p)-[:ACTED_IN]->(m:Movie)-[:IN_GENRE]->(g:Genre)
WITH p, collect(DISTINCT g.name) AS genres
RETURN p.name AS actor, genres
```

## Unwinding Lists

### Using UNWIND
```cypher
MATCH (m:Movie)-[:ACTED_IN]-(a:Actor)
WHERE a.name = 'Tom Hanks'
UNWIND m.languages AS lang
RETURN m.title AS movie,
m.languages AS languages,
lang AS language
```

```cypher
MATCH (m:Movie)
UNWIND m.languages AS lang
WITH m, trim(lang) AS language
// this automatically, makes the language distinct because it's a grouping key
WITH language, collect(m.title) AS movies
RETURN language, movies[0..10]
```
## Subqueries

### Performing subqueries with CALL
```cypher
CALL {
   MATCH (m:Movie) WHERE m.year = 2000
   RETURN m ORDER BY m.imdbRating DESC LIMIT 10
}
MATCH  (:User)-[r:RATED]->(m)
RETURN m.title, avg(r.rating)
```
### Passing variables into a subquery
```cypher
MATCH (m:Movie)
CALL {
    WITH m
    MATCH (m)<-[r:RATED]-(u:User)
     WHERE r.rating = 5
    RETURN count(u) AS numReviews
}
RETURN m.title, numReviews
ORDER BY numReviews DESC
```

### Combining query results with UNION
```cypher
MATCH (m:Movie) WHERE m.year = 2000
RETURN {type:"movies", theMovies: collect(m.title)} AS data
UNION ALL
MATCH (a:Actor) WHERE a.born.year > 2000
RETURN { type:"actors", theActors: collect(DISTINCT a.name)} AS data
```
Understanding UNION vs UNION ALL

UNION ALL returns all results which is more efficient on memory but can lead to duplicates. UNION returns distinct results.

### Using UNION with subqueries
```cypher
MATCH (p:Person)
WITH p LIMIT 100
CALL {
  WITH p
  OPTIONAL MATCH (p)-[:ACTED_IN]->(m:Movie)
  RETURN m.title + ": " + "Actor" AS work
UNION
  WITH p
  OPTIONAL MATCH (p)-[:DIRECTED]->(m:Movie)
  RETURN m.title+ ": " +  "Director" AS work
}
RETURN p.name, collect(work)
```

## Parameters in Cypher

### Using Cypher parameters
```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = $actorName
RETURN m.released AS releaseDate,
m.title AS title
ORDER BY m.released DESC
```

### Setting a parameter
```cypher
:param actorName: 'Tom Hanks'
```

### Setting multiple parameters
```cypher
:params {actorName: 'Tom Cruise', movieName: 'Top Gun'}
```

### Using multiple parameters
```cypher
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = $actorName
AND m.title = $movieName
RETURN p, m
```

### Viewing parameters
```cypher
:params
```

### Removing parameters
```cypher
:params {}
```

## Example: Python
```python
def get_actors(tx, movieTitle): # (1)
  result = tx.run("""
    MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
    WHERE m.title = $title
    RETURN p
  """, title=movieTitle)

  # Access the `p` value from each record
  return [ record["p"] for record in result ]

with driver.session() as session:
    result = session.read_transaction(get_actors, movieTitle="Toy Story")
```